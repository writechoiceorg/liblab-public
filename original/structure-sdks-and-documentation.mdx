# Structure of the generated SDKs and their documentation

After running the `liblab build` CLI command to generate your SDK and its relevant documentation, it's essential to understand the structure of the SDK, whether you're providing it to your end users or using it for your own projects. This guide offers an overview of the common elements found across SDKs generated by liblab and the language-specific nuances tailored to each supported programming language. Whether your goal is to help your end users integrate more easily with your API or to effectively utilize the SDK in your own development work, understanding these structures will be key to maximizing the benefits of the SDKs generated by liblab.

## Common structure across SDKs

The SDKs generated by liblab share a consistent structure across different programming languages, making working with multiple SDKs easier. Each SDK includes the following key components:

- **License and README:** Every generated SDK includes a `LICENSE` file and a `README.md` file, both of which are standard in all software projects. The `LICENSE` file outlines the SDK's licensing terms and usage guidelines, ensuring that users understand their rights and obligations when using the software.

  The `README.md` file is crucial as it is the starting point for integrating the SDK. This file provides comprehensive guidance on how to get up and running with the SDK and the API it wraps. It typically includes:
    - **Installation Instructions:** Step-by-step guidance on installing the SDK in the target environment.
    - **Authentication Setup:** Details on authenticating against the API, ensuring secure access.
    - **Sample Usage:** Code snippets that demonstrate how to interact with the API, allowing users to quickly understand and implement key functionality.
    - **Documentation Overview:** Links to more detailed documentation within the SDK, such as services and models, which provide deeper insights into the available API resources and operations.

  The `README.md` file is designed to help users get started immediately with the SDK, making it easier to integrate the API into their projects. The file's content is tailored to each SDK's programming language, ensuring that the examples and instructions align with the best practices of that language.

- **Documentation Folder:** The `documentation` folder is a significant part of each SDK, containing detailed Markdown files for the resources and methods defined in the API specification. These files are linked from the `README.md` file to provide basic documentation on interacting with the API through the SDK. This setup becomes especially useful when you host your SDK on GitHub or similar code hosting platforms, as they render Markdown files, giving you navigable and accessible documentation.

  The `documentation` folder contains the following subfolders:
  - **`models` Folder:** This folder contains the API resources, representing the data structures defined in the API specification.
  - **`services` Folder:** Documents the methods or operations associated with each resource, detailing how to interact with the API endpoints.
  - **`snippets` Folder:** Provides [code snippets](https://developers.liblab.com/sdk-docs/sdk-docs-overview#sdk-snippets), either as multiple Markdown files or one single JSON file depending on your configuration. This folder is available only if you [configure liblab to include SDK snippets in the generated documentation](https://developers.liblab.com/sdk-docs/generate-docs#generate-sdk-snippets).

- **Example Code:** To help you quickly get started, each SDK includes an `examples` (or `Example`) folder. This folder contains [a simple, runnable example](https://developers.liblab.com/get-started/quickstart-generate-sdk#run-an-example) that demonstrates how to use the SDK to call an API endpoint, allowing you to see the SDK in action without needing to build an entire application first.

- **Source Code Organization:** Most SDKs include an `src` folder or one that's based on the [`sdkName`](https://developers.liblab.com/cli/config-file-overview-root#sdkname) value in your liblab configuration file. This folder contains the core implementation of the SDK, including the following folders:
    - **`models`:** These are classes representing the data structures defined in the API spec (e.g., `Llama`, `ApiToken`).
    - **`services`:** These classes contain methods to interact with the API endpoints, reflecting the operations specified in the API spec.

    This organization makes it easier to locate and work with different parts of the SDK, whether you're implementing new features or debugging existing ones.

## Illustrating common SDK structures

Check your generated SDKs inside your working directory's `output` folder. Each SDK language specified in your liblab config file will have one folder per language. Based on our example liblab config, the languages **C#**, **Python**, and **TypeScript** were listed.

For C#, this is the generated SDK structure:
```
csharp
├── Example
│   ├── Example.csproj
│   └── Program.cs
├── LICENSE
├── MyEx1Sdk
│   ├── ...
│   ├── Models
│   └── Services
├── README.md
├── documentation
│   ├── models
│   │   ├── ApiToken.md
│   │   ├── ApiTokenRequest.md
│   │   ├── Llama.md
│   │   ├── LlamaColor.md
│   │   ├── LlamaCreate.md
│   │   ├── LlamaId.md
│   │   ├── User.md
│   │   └── UserRegistration.md
│   ├── services
│   │   ├── LlamaPictureService.md
│   │   ├── LlamaService.md
│   │   ├── TokenService.md
│   │   └── UserService.md
│   └── snippets
│       └── snippets.json
└── install.sh
```

And this is Python's SDK structure:
```
python
├── LICENSE
├── README.md
├── documentation
│   ├── models
│   │   ├── ApiToken.md
│   │   ├── ApiTokenRequest.md
│   │   ├── Llama.md
│   │   ├── LlamaColor.md
│   │   ├── LlamaCreate.md
│   │   ├── LlamaId.md
│   │   ├── User.md
│   │   └── UserRegistration.md
│   ├── services
│   │   ├── LlamaPictureService.md
│   │   ├── LlamaService.md
│   │   ├── TokenService.md
│   │   └── UserService.md
│   └── snippets
│       └── snippets.json
├── examples
│   ├── install.cmd
│   ├── install.sh
│   └── sample.py
├── install.cmd
├── install.sh
├── pyproject.toml
└── src
    └── my_ex1_sdk
        ├── models
        ├── ...
        └── services
```

Lastly, this is TypeScript's structure:
```
typescript
├── LICENSE
├── README.md
├── documentation
│   ├── models
│   │   ├── ApiToken.md
│   │   ├── ApiTokenRequest.md
│   │   ├── Llama.md
│   │   ├── LlamaColor.md
│   │   ├── LlamaCreate.md
│   │   ├── LlamaId.md
│   │   ├── User.md
│   │   └── UserRegistration.md
│   ├── services
│   │   ├── LlamaPictureService.md
│   │   ├── LlamaService.md
│   │   ├── TokenService.md
│   │   └── UserService.md
│   └── snippets
│       └── snippets.json
├── examples
│   ├── README.md
│   ├── package.json
│   ├── src
│   │   └── index.ts
│   └── tsconfig.json
├── node_modules
├── package-lock.json
├── package.json
├── src
│   └── ...
└── tsconfig.json
```

As described in the earlier section, the following remains true across the SDKs generated by liblab:

1. The `LICENSE` and `README.md` files are standard.
2. The `documentation` folder and its subfolders.
3. The folder containing the example program that quickly demonstrates the SDK in use.

liblab implements a consistent standard for organizing code and documentation across the SDKs it generates. As you've seen, the SDK structures for these three languages share more similarities than differences, providing a unified experience. However, there are also important language-specific differences that you should be aware of, which we'll explore in the next section.

## SDK language-specific structures

While liblab maintains a consistent structure across the SDKs it generates, each programming language has unique conventions that influence how the SDK's core code is organized. For instance, the `src` folder is a standard convention in many languages; liblab adheres to this when appropriate. This is true and applicable to Python and TypeScript. liblab generates SDK structure for both languages that utilize the `src` naming convention for their core SDK folder.

```
python
├── documentation
│   ├── models
│   ├── services
│   └── snippets
├── examples
└── src
    └── my_ex1_sdk
        ├── hooks
        ├── models
        │   └── utils
        ├── net
        │   ├── environment
        │   ├── headers
        │   ├── request_chain
        │   │   └── handlers
        │   └── transport
        └── services
            └── utils
```

<br/>

```
typescript
├── documentation
│   ├── models
│   ├── services
│   └── snippets
├── examples
│   └── src
├── node_modules
└── src
    ├── http
    │   ├── handlers
    │   ├── hooks
    │   ├── serialization
    │   └── transport
    └── services
        ├── llama
        │   └── models
        ├── llama-picture
        │   └── models
        ├── token
        │   └── models
        └── user
            └── models
```

However, for languages with different conventions, liblab uses the `sdkName` property from the configuration file to name the main SDK folder, formatting it according to the language's standards—such as Pascal case for C# or Snake case for Python.

```
csharp
├── Example
├── MyEx1Sdk
│   ├── Config
│   ├── Http
│   │   ├── Handlers
│   │   └── Serialization
│   ├── Json
│   ├── Models
│   └── Services
└── documentation
    ├── models
    ├── services
    └── snippets
```

Python's SDK structure utilizes both `src` and the value of the `sdkName` property from the liblab config file.

```
python
├── documentation
│   ├── ...
├── examples
└── src
    └── my_ex1_sdk
        ├── ...
        ├── models
        └── services
```

Each language also has its approach to separation of concerns (SoC), ensuring that components like data models, services, and utilities are organized according to the language's best practices. liblab adheres to these conventions, providing SDK structures that naturally fit within the development standards of each supported language.

For example, in the Python SDK, the `src/my_ex1_sdk` directory houses the core SDK files, with a clear separation between models, services, and utilities. This organization follows Python's traditional approach, where components are kept in distinct subfolders, supporting maintainability and readability.

By aligning with these established practices, liblab ensures that its generated SDKs are consistent and adaptable to the unique demands of each programming language, making them easier to extend, modify, and integrate into your projects.
